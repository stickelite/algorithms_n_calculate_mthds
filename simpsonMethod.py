import math
user_function = input("Введите функцию, если она сложная используйте: math.: ")
a = float(input("Введите нижний предел: "))
b = float(input("Введите верхний предел: "))
min_partitions = int(input("Введите минимальное число разбиейний: "))
max_partitions = int(input("Введите максимальное число разбиейний: "))
target_error = float(input("Введите погрешность: "))

def f(x):
    try:
        result = eval(user_function)
        return result
    except (SyntaxError, NameError) as e:
        print("Произошла ошибка:", e)


def simpson_integration(): # ф - функция, а б - пределы, мин макс партишн - макс и мин число разбиений, таргет еррор -
    partitions = min_partitions # кол-во разбиейний на начальном этапе = мин. кол-ву разбиений
    prev_result = 0 #пред результ
    curr_result = 0 #текущ результ
    error = float('inf') #положительная бесконечность - введена тут, чтобы цикл мог хотя бы раз сработать

    while partitions <= max_partitions and error > target_error: # пока кол-во разбиений <= макс. кол-ву разбиений и погрешность больше заданной делаем:
        h = (b - a) / partitions # считаем шаг на основе кол-ва разбиений
        x = a # записываем нижний предел, чтобы пошагово идти до верхнего предела и не потерять значение нижнего

        curr_result = f(a) + f(b)  # текущий результат, сразу записываем сумму крайних пределов, то есть нижний верхний

        for i in range(1, partitions): #цикл от 1 до кол-ва разбиений, то есть каждый отрезок считаем тут
            x += h # делаем шаг
            if i % 2 == 0: # если четный предел
                curr_result += 2 * f(x) # вычисляем значение функции в пределе и умножаем на 2
            else:
                curr_result += 4 * f(x) # иначе вычисляем значение ф-ции и умножаем на 4

        curr_result *= h / 3 # в конце добавляем h/3, по формуле
        error = abs(curr_result - prev_result) / 15 # вычисляем погрешность по формуле Рунге

        prev_result = curr_result # запоминаем текущий результат в предыдущий
        partitions *= 2 # увеличиваем кол-во разбиений

    print(partitions // 2, error)
    #возвращаем кол-во разбиений деленное на 2, так как в конце цикла делается умножение на 2 для след. шага,
    #но так как мы нашли что хотели, то дальше не пойдем и нам нужно вернуть кол-во разбиений на место, то есть поделить на 2
    #также возвращаем погрешность по условию задачи


simpson_integration()
#print(simpson_integration(f,0,math.pi,2,1024,1e-6))
